---
author: mantic
title: 所有权
date: 2024-07-04 10:00:00
summary: 介绍rust的所有权概念
usePageBundles: true
series: ["Rust程序设计语言"]
---

## 什么是所有权

所有程序都必须管理其运行时使用计算机内存的方式。
- 一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；
- 在另一些语言中，程序员必须亲自分配和释放内存。
- Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序。

#### 堆与栈

栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）；栈中的所有数据都必须占用已知且固定的大小。

在编译时大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。这个过程称作 在堆上分配内存（allocating on the heap）。

所有权的主要目的就是管理堆数据。它解决的问题：
- 跟踪代码的哪些部分正在使用heap的哪些数据
- 最小化heap上的重复数据量
- 清理heap上未使用的数据以避免空间不足。

所有权规则：

- Rust 中的每一个值都有一个 所有者（owner）。
- 值在任一时刻有且只有一个所有者。
- 当所有者（变量）离开作用域，这个值将被丢弃。

#### 从String类型理解所有权

先看下字符串字面值与String类型的区别：
- 字符串字面值，即被硬编码进程序里的字符串值，它们是不可变的；
- String类型，这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String，`let s = String::from("hello");`

String类型可以被修改，而字符串字面值不行，这是为什么呢？区别在于两个类型对内存的处理上。

就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。

对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：

- 必须在运行时向内存分配器（memory allocator）请求内存。
- 需要一个当我们处理完 String 时将内存返回给分配器的方法。

第一部分由我们完成：当调用 `String::from` 时，它的实现 (implementation) 请求其所需的内存。这在编程语言中是非常通用的。

然而，第二部分实现起来就各有区别了。在有 `垃圾回收（garbage collector，GC）` 的语言中，`GC` 记录并清除不再使用的内存，而我们并不需要关心它。在大部分没有 `GC` 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 `allocate` 配对一个 `free`。

Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 `drop`，在这里 `String` 的作者可以放置释放内存的代码。Rust 在结尾的 `}` 处自动调用 `drop`。

#### 变量与数据交互的方式（一）：移动（Move）

`String` 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。长度表示 String 的内容当前使用了多少字节的内存。容量是 String 从分配器总共获取了多少字节的内存。

![](./images/2024-07-06_00-44-04.png '图4-1 将值 "hello" 绑定给 s1 的 String 在内存中的表现形式')

```rust
    let s1 = String::from("hello");
    let s2 = s1;
```

当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。

![](./images/2024-07-06_00-46-27.png '图4-2 变量 s2 的内存表现，它有一份 s1 指针、长度和容量的拷贝')

之前我们提到过当变量离开作用域后，Rust 自动调用 `drop` 函数并清理变量的堆内存。不过 图4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 `二次释放（double free）` 的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。为了确保内存安全，在 `let s2 = s1`; 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。

如果你在其他语言中听说过术语 `浅拷贝（shallow copy）` 和 `深拷贝（deep copy）`，那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 `移动（move）`，而不是叫做浅拷贝。上面的例子可以解读为 s1 被 移动 到了 s2 中。那么具体发生了什么，如图 4-3 所示。

![](./images/2024-07-06_00-49-50.png '图 4-3： s1 无效之后的内存表现')

这样就解决了我们的问题！因为只有 s2 是有效的，当其离开作用域，它就释放自己的内存，完毕。

另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。

#### 变量与数据交互的方式（二）：克隆（Clone）

如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 `clone` 的通用函数。

```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {s1}, s2 = {s2}");
```

这段代码能正常运行，并且明确产生图 4-4 中行为，这里堆上的数据 确实 被复制了。

![](./images/2024-07-06_00-52-11.png '图 4-4： 使用clone后，Rust 同时也拷贝了堆上的数据')

#### 只在栈上的数据：拷贝

这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 `clone`，不过 x 依然有效且没有被移动到 y 中。

```rust
    let x = 5;
    let y = x;

    println!("x = {x}, y = {y}");
```

原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它。

Rust 有一个叫做 `Copy trait` 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章将会详细讲解 trait）。如果一个类型实现了 `Copy trait`，那么一个旧的变量在将其赋值给其他变量后仍然可用。

{{%/* notice note "重要" */%}}
Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。
{{%/* /notice */%}}

那么哪些类型实现了 `Copy trait` 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：

- 所有整数类型，比如 u32。
- 布尔类型，bool，它的值是 true 和 false。
- 所有浮点数类型，比如 f64。
- 字符类型，char。
- 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。
- 数组，当且仅当其包含的类型也都实现 Copy 的时候。

#### 所有权与函数

将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。

## 引用与借用

引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。 与指针不同，引用确保指向某个特定类型的有效值。

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

注意我们传递 `&s1` 给 calculate_length，同时在函数定义中，我们获取 `&String` 而不是 `String`。这些 `&` 符号就是 `引用`，它们允许你使用值但不获取其所有权。变量 `s`有效的作用域与函数参数的作用域一样，不过当 `s` 停止使用时并不丢弃引用指向的数据，因为 `s` 并没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。

![](./images/2024-07-07_20-31-26.png '图 4-5：&String s 指向 String s1 示意图')

我们将创建一个引用的行为称为 `借用（borrowing）`。

#### 可变引用（mutable reference）

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

可变引用有几个限制：

- 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
- 引用必须总是有效的，不能有悬垂引用。

这些限制的好处是 Rust 可以在编译时就避免数据竞争。`数据竞争（data race）`类似于竞态条件，它可由这三个行为造成：

- 两个或更多指针同时访问同一数据。
- 至少有一个指针被用来写入数据。
- 没有同步数据访问的机制。

注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。因此如下代码可以编译：

```rust
    let mut s = String::from("hello");

    let r1 = &s; // 没问题
    let r2 = &s; // 没问题
    println!("{} and {}", r1, r2);
    // 此位置之后 r1 和 r2 不再使用

    let r3 = &mut s; // 没问题
    println!("{}", r3);
```

悬垂指针（dangling pointer）: 一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了。在 rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。

## Slice类型

`slice` 允许你引用集合中一段连续的元素序列，而不用引用整个集合。`slice` 是一种引用，所以它没有所有权。

#### 字符串slice

字符串 slice（string slice）是 String 中一部分值的引用。形式： `[开始索引..结束索引]`

```rust
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
```

![](./images/2024-07-07_21-26-23.png '图 4-6：引用了部分 String 的字符串 slice')

字符串字面值实际上就是一个切片。`let s = "Hello, world!";` 这里 `s` 的类型是 `&str`：它是一个指向二进制程序特定位置的 `slice`。这也就是为什么字符串字面值是不可变的；`&str` 是一个不可变引用。

#### 其他类型的slice

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

这个 slice 的类型是 `&[i32]`。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。
